// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// A very short-lived native function.
///
/// For very short-lived functions, it is fine to call them on the main isolate.
/// They will block the Dart execution while running the native function, so
/// only do this for native functions which are guaranteed to be short-lived.
@ffi.Native<ffi.IntPtr Function(ffi.IntPtr, ffi.IntPtr)>()
external int sum(int a, int b);

/// A longer lived native function, which occupies the thread calling it.
///
/// Do not call these kind of native functions in the main isolate. They will
/// block Dart execution. This will cause dropped frames in Flutter applications.
/// Instead, call these native functions on a separate isolate.
@ffi.Native<ffi.IntPtr Function(ffi.IntPtr, ffi.IntPtr)>()
external int sum_long_running(int a, int b);

/// Create a pair of FIFOs with unique names in the specified directory.
///
/// The caller is responsible for freeing the returned path strings with free().
/// The caller should also remove the FIFOs when done using unlink() or remove().
///
/// @param[in]   context    A valid context object.
/// @param[in]   directory  The directory in which to create the FIFOs.
/// @param[out]  read_path  A location to store the allocated read FIFO path.
/// @param[out]  write_path A location to store the allocated write FIFO path.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_context_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
  symbol: "dc_fifos_create",
)
external int _dc_fifos_create(
  ffi.Pointer<dc_context_t> context,
  ffi.Pointer<ffi.Char> directory,
  ffi.Pointer<ffi.Pointer<ffi.Char>> read_path,
  ffi.Pointer<ffi.Pointer<ffi.Char>> write_path,
);

dc_status_t dc_fifos_create(
  ffi.Pointer<dc_context_t> context,
  ffi.Pointer<ffi.Char> directory,
  ffi.Pointer<ffi.Pointer<ffi.Char>> read_path,
  ffi.Pointer<ffi.Pointer<ffi.Char>> write_path,
) => dc_status_t.fromValue(_dc_fifos_create(context, directory, read_path, write_path));

/// Open a FIFO-based connection using a pair of named pipes.
///
/// @param[out]  iostream   A location to store the FIFO connection.
/// @param[in]   context    A valid context object.
/// @param[in]   read_path  The path to the FIFO to read from.
/// @param[in]   write_path The path to the FIFO to write to.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<dc_iostream_t>>, ffi.Pointer<dc_context_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(
  symbol: "dc_fifos_open",
)
external int _dc_fifos_open(
  ffi.Pointer<ffi.Pointer<dc_iostream_t>> iostream,
  ffi.Pointer<dc_context_t> context,
  ffi.Pointer<ffi.Char> read_path,
  ffi.Pointer<ffi.Char> write_path,
);

dc_status_t dc_fifos_open(
  ffi.Pointer<ffi.Pointer<dc_iostream_t>> iostream,
  ffi.Pointer<dc_context_t> context,
  ffi.Pointer<ffi.Char> read_path,
  ffi.Pointer<ffi.Char> write_path,
) => dc_status_t.fromValue(_dc_fifos_open(iostream, context, read_path, write_path));

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<dc_context_t>>)>(symbol: "dc_context_new")
external int _dc_context_new(ffi.Pointer<ffi.Pointer<dc_context_t>> context);

dc_status_t dc_context_new(ffi.Pointer<ffi.Pointer<dc_context_t>> context) => dc_status_t.fromValue(_dc_context_new(context));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_context_t>)>(symbol: "dc_context_free")
external int _dc_context_free(ffi.Pointer<dc_context_t> context);

dc_status_t dc_context_free(ffi.Pointer<dc_context_t> context) => dc_status_t.fromValue(_dc_context_free(context));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_context_t>, ffi.UnsignedInt)>(symbol: "dc_context_set_loglevel")
external int _dc_context_set_loglevel(ffi.Pointer<dc_context_t> context, int loglevel);

dc_status_t dc_context_set_loglevel(ffi.Pointer<dc_context_t> context, dc_loglevel_t loglevel) =>
    dc_status_t.fromValue(_dc_context_set_loglevel(context, loglevel.value));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_context_t>, dc_logfunc_t, ffi.Pointer<ffi.Void>)>(symbol: "dc_context_set_logfunc")
external int _dc_context_set_logfunc(ffi.Pointer<dc_context_t> context, dc_logfunc_t logfunc, ffi.Pointer<ffi.Void> userdata);

dc_status_t dc_context_set_logfunc(ffi.Pointer<dc_context_t> context, dc_logfunc_t logfunc, ffi.Pointer<ffi.Void> userdata) =>
    dc_status_t.fromValue(_dc_context_set_logfunc(context, logfunc, userdata));

@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<dc_context_t>)>()
external int dc_context_get_transports(ffi.Pointer<dc_context_t> context);

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iterator_t>, ffi.Pointer<ffi.Void>)>(symbol: "dc_iterator_next")
external int _dc_iterator_next(ffi.Pointer<dc_iterator_t> iterator, ffi.Pointer<ffi.Void> item);

dc_status_t dc_iterator_next(ffi.Pointer<dc_iterator_t> iterator, ffi.Pointer<ffi.Void> item) => dc_status_t.fromValue(_dc_iterator_next(iterator, item));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iterator_t>)>(symbol: "dc_iterator_free")
external int _dc_iterator_free(ffi.Pointer<dc_iterator_t> iterator);

dc_status_t dc_iterator_free(ffi.Pointer<dc_iterator_t> iterator) => dc_status_t.fromValue(_dc_iterator_free(iterator));

/// Create an iterator to enumerate the supported dive computers.
///
/// @param[out] iterator  A location to store the iterator.
/// @param[in]  context   A valid device descriptor.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<dc_iterator_t>>, ffi.Pointer<dc_context_t>)>(symbol: "dc_descriptor_iterator_new")
external int _dc_descriptor_iterator_new(ffi.Pointer<ffi.Pointer<dc_iterator_t>> iterator, ffi.Pointer<dc_context_t> context);

dc_status_t dc_descriptor_iterator_new(ffi.Pointer<ffi.Pointer<dc_iterator_t>> iterator, ffi.Pointer<dc_context_t> context) =>
    dc_status_t.fromValue(_dc_descriptor_iterator_new(iterator, context));

/// Free the device descriptor.
///
/// @param[in]  descriptor  A valid device descriptor.
@ffi.Native<ffi.Void Function(ffi.Pointer<dc_descriptor_t>)>()
external void dc_descriptor_free(ffi.Pointer<dc_descriptor_t> descriptor);

/// Get the vendor name of the dive computer.
///
/// @param[in]  descriptor  A valid device descriptor.
/// @returns The vendor name of the dive computer on success, or NULL on failure.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<dc_descriptor_t>)>()
external ffi.Pointer<ffi.Char> dc_descriptor_get_vendor(ffi.Pointer<dc_descriptor_t> descriptor);

/// Get the product name of the dive computer.
///
/// @param[in]  descriptor  A valid device descriptor.
/// @returns The product name of the dive computer on success, or NULL on
/// failure.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<dc_descriptor_t>)>()
external ffi.Pointer<ffi.Char> dc_descriptor_get_product(ffi.Pointer<dc_descriptor_t> descriptor);

/// Get the family type of the dive computer.
///
/// @param[in]  descriptor  A valid device descriptor.
/// @returns The family type of the dive computer on success, or DC_FAMILY_NULL
/// on failure.
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<dc_descriptor_t>)>(symbol: "dc_descriptor_get_type")
external int _dc_descriptor_get_type(ffi.Pointer<dc_descriptor_t> descriptor);

dc_family_t dc_descriptor_get_type(ffi.Pointer<dc_descriptor_t> descriptor) => dc_family_t.fromValue(_dc_descriptor_get_type(descriptor));

/// Get the model number of the dive computer.
///
/// @param[in]  descriptor  A valid device descriptor.
/// @returns The model number of the dive computer on success, or zero on
/// failure.
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<dc_descriptor_t>)>()
external int dc_descriptor_get_model(ffi.Pointer<dc_descriptor_t> descriptor);

/// Get all transports supported by the dive computer.
///
/// @param[in]  descriptor  A valid device descriptor.
/// @returns A bitmask with all the transports supported by the dive computer on
/// success, or DC_TRANSPORT_NONE on failure.
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<dc_descriptor_t>)>()
external int dc_descriptor_get_transports(ffi.Pointer<dc_descriptor_t> descriptor);

/// Check if a low-level I/O device matches a supported dive computer.
///
/// @param[in]  descriptor  A valid device descriptor.
/// @param[in]  transport   The transport type of the I/O device.
/// @param[in]  userdata    A pointer to a transport specific data structure:
/// - DC_TRANSPORT_SERIAL:    Name of the device node (string)
/// - DC_TRANSPORT_USB:       USB VID/PID (#dc_usb_desc_t)
/// - DC_TRANSPORT_USBHID:    USB VID/PID (#dc_usbhid_desc_t)
/// - DC_TRANSPORT_IRDA:      IrDA device name (string)
/// - DC_TRANSPORT_BLUETOOTH: Bluetooth device name (string)
/// - DC_TRANSPORT_BLE:       Bluetooth device name (string)
/// @returns Non-zero if the device matches a supported dive computer, or zero if
/// there is no match.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_descriptor_t>, ffi.UnsignedInt, ffi.Pointer<ffi.Void>)>(symbol: "dc_descriptor_filter")
external int _dc_descriptor_filter(ffi.Pointer<dc_descriptor_t> descriptor, int transport, ffi.Pointer<ffi.Void> userdata);

int dc_descriptor_filter(ffi.Pointer<dc_descriptor_t> descriptor, dc_transport_t transport, ffi.Pointer<ffi.Void> userdata) =>
    _dc_descriptor_filter(descriptor, transport.value, userdata);

/// Get the transport type.
///
/// @param[in]  iostream  A valid I/O stream.
/// @returns The transport type of the I/O stream.
@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<dc_iostream_t>)>(symbol: "dc_iostream_get_transport")
external int _dc_iostream_get_transport(ffi.Pointer<dc_iostream_t> iostream);

dc_transport_t dc_iostream_get_transport(ffi.Pointer<dc_iostream_t> iostream) => dc_transport_t.fromValue(_dc_iostream_get_transport(iostream));

/// Set the read timeout.
///
/// There are three distinct modes available:
///
/// 1. Blocking (timeout < 0):
///
/// The read operation is blocked until all the requested bytes have
/// been received. If the requested number of bytes does not arrive,
/// the operation will block forever.
///
/// 2. Non-blocking (timeout == 0):
///
/// The read operation returns immediately with the bytes that have
/// already been received, even if no bytes have been received.
///
/// 3. Timeout (timeout > 0):
///
/// The read operation is blocked until all the requested bytes have
/// been received. If the requested number of bytes does not arrive
/// within the specified amount of time, the operation will return
/// with the bytes that have already been received.
///
/// @param[in]  iostream  A valid I/O stream.
/// @param[in]  timeout   The timeout in milliseconds.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.Int)>(symbol: "dc_iostream_set_timeout")
external int _dc_iostream_set_timeout(ffi.Pointer<dc_iostream_t> iostream, int timeout);

dc_status_t dc_iostream_set_timeout(ffi.Pointer<dc_iostream_t> iostream, int timeout) => dc_status_t.fromValue(_dc_iostream_set_timeout(iostream, timeout));

/// Set the state of the break condition.
///
/// @param[in]  iostream  A valid I/O stream.
/// @param[in]  value     The break condition state.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.UnsignedInt)>(symbol: "dc_iostream_set_break")
external int _dc_iostream_set_break(ffi.Pointer<dc_iostream_t> iostream, int value);

dc_status_t dc_iostream_set_break(ffi.Pointer<dc_iostream_t> iostream, int value) => dc_status_t.fromValue(_dc_iostream_set_break(iostream, value));

/// Set the state of the DTR line.
///
/// @param[in]  iostream  A valid I/O stream.
/// @param[in]  value     The DTR line state.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.UnsignedInt)>(symbol: "dc_iostream_set_dtr")
external int _dc_iostream_set_dtr(ffi.Pointer<dc_iostream_t> iostream, int value);

dc_status_t dc_iostream_set_dtr(ffi.Pointer<dc_iostream_t> iostream, int value) => dc_status_t.fromValue(_dc_iostream_set_dtr(iostream, value));

/// Set the state of the RTS line.
///
/// @param[in]  iostream  A valid I/O stream.
/// @param[in]  value     The RTS line state.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.UnsignedInt)>(symbol: "dc_iostream_set_rts")
external int _dc_iostream_set_rts(ffi.Pointer<dc_iostream_t> iostream, int value);

dc_status_t dc_iostream_set_rts(ffi.Pointer<dc_iostream_t> iostream, int value) => dc_status_t.fromValue(_dc_iostream_set_rts(iostream, value));

/// Query the state of the line signals.
///
/// @param[in]   iostream  A valid I/O stream.
/// @param[out]  value     A location to store the bitmap with the state
/// of the line signals.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.UnsignedInt>)>(symbol: "dc_iostream_get_lines")
external int _dc_iostream_get_lines(ffi.Pointer<dc_iostream_t> iostream, ffi.Pointer<ffi.UnsignedInt> value);

dc_status_t dc_iostream_get_lines(ffi.Pointer<dc_iostream_t> iostream, ffi.Pointer<ffi.UnsignedInt> value) =>
    dc_status_t.fromValue(_dc_iostream_get_lines(iostream, value));

/// Query the number of available bytes in the input buffer.
///
/// @param[in]   iostream  A valid I/O stream.
/// @param[out]  value     A location to store the number of bytes in the
/// input buffer.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.Size>)>(symbol: "dc_iostream_get_available")
external int _dc_iostream_get_available(ffi.Pointer<dc_iostream_t> iostream, ffi.Pointer<ffi.Size> value);

dc_status_t dc_iostream_get_available(ffi.Pointer<dc_iostream_t> iostream, ffi.Pointer<ffi.Size> value) =>
    dc_status_t.fromValue(_dc_iostream_get_available(iostream, value));

/// Configure the line settings.
///
/// @param[in]  iostream     A valid I/O stream.
/// @param[in]  baudrate     The baud rate setting.
/// @param[in]  databits     The number of data bits.
/// @param[in]  parity       The parity setting.
/// @param[in]  stopbits     The number of stop bits.
/// @param[in]  flowcontrol  The flow control setting.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.UnsignedInt, ffi.UnsignedInt, ffi.UnsignedInt, ffi.UnsignedInt, ffi.UnsignedInt)>(
  symbol: "dc_iostream_configure",
)
external int _dc_iostream_configure(ffi.Pointer<dc_iostream_t> iostream, int baudrate, int databits, int parity, int stopbits, int flowcontrol);

dc_status_t dc_iostream_configure(
  ffi.Pointer<dc_iostream_t> iostream,
  int baudrate,
  int databits,
  dc_parity_t parity,
  dc_stopbits_t stopbits,
  dc_flowcontrol_t flowcontrol,
) => dc_status_t.fromValue(_dc_iostream_configure(iostream, baudrate, databits, parity.value, stopbits.value, flowcontrol.value));

/// Poll the I/O stream for available data.
///
/// There are three distinct modes available:
///
/// 1. Blocking (timeout < 0):
///
/// The poll operation is blocked until one or more bytes have been
/// received. If no bytes are received, the operation will block
/// forever.
///
/// 2. Non-blocking (timeout == 0):
///
/// The poll operation returns immediately, even if no bytes have
/// been received.
///
/// 3. Timeout (timeout > 0):
///
/// The poll operation is blocked until one or more bytes have been
/// received. If no bytes are received within the specified amount of
/// time, the operation will return with a timeout.
///
/// @param[in]  iostream  A valid I/O stream.
/// @param[in]  timeout   The timeout in milliseconds.
/// @returns #DC_STATUS_SUCCESS on success, #DC_STATUS_TIMEOUT on
/// timeout, or another #dc_status_t code on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.Int)>(symbol: "dc_iostream_poll")
external int _dc_iostream_poll(ffi.Pointer<dc_iostream_t> iostream, int timeout);

dc_status_t dc_iostream_poll(ffi.Pointer<dc_iostream_t> iostream, int timeout) => dc_status_t.fromValue(_dc_iostream_poll(iostream, timeout));

/// Read data from the I/O stream.
///
/// @param[in]  iostream  A valid I/O stream.
/// @param[out] data      The memory buffer to read the data into.
/// @param[in]  size      The number of bytes to read.
/// @param[out] actual    An (optional) location to store the actual
/// number of bytes transferred.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Pointer<ffi.Size>)>(symbol: "dc_iostream_read")
external int _dc_iostream_read(ffi.Pointer<dc_iostream_t> iostream, ffi.Pointer<ffi.Void> data, int size, ffi.Pointer<ffi.Size> actual);

dc_status_t dc_iostream_read(ffi.Pointer<dc_iostream_t> iostream, ffi.Pointer<ffi.Void> data, int size, ffi.Pointer<ffi.Size> actual) =>
    dc_status_t.fromValue(_dc_iostream_read(iostream, data, size, actual));

/// Write data to the I/O stream.
///
/// @param[in]  iostream  A valid I/O stream.
/// @param[in]  data      The memory buffer to write the data from.
/// @param[in]  size      The number of bytes to write.
/// @param[out] actual    An (optional) location to store the actual
/// number of bytes transferred.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Pointer<ffi.Size>)>(symbol: "dc_iostream_write")
external int _dc_iostream_write(ffi.Pointer<dc_iostream_t> iostream, ffi.Pointer<ffi.Void> data, int size, ffi.Pointer<ffi.Size> actual);

dc_status_t dc_iostream_write(ffi.Pointer<dc_iostream_t> iostream, ffi.Pointer<ffi.Void> data, int size, ffi.Pointer<ffi.Size> actual) =>
    dc_status_t.fromValue(_dc_iostream_write(iostream, data, size, actual));

/// Perform an I/O stream specific request.
///
/// @param[in]  iostream  A valid I/O stream.
/// @param[in]  request   The request to perform.
/// @param[in,out]  data  The request specific data.
/// @param[in]  size      The size of the request specific data.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.UnsignedInt, ffi.Pointer<ffi.Void>, ffi.Size)>(symbol: "dc_iostream_ioctl")
external int _dc_iostream_ioctl(ffi.Pointer<dc_iostream_t> iostream, int request, ffi.Pointer<ffi.Void> data, int size);

dc_status_t dc_iostream_ioctl(ffi.Pointer<dc_iostream_t> iostream, int request, ffi.Pointer<ffi.Void> data, int size) =>
    dc_status_t.fromValue(_dc_iostream_ioctl(iostream, request, data, size));

/// Flush the internal output buffer and wait until the data has been
/// transmitted.
///
/// @param[in]  iostream  A valid I/O stream.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>)>(symbol: "dc_iostream_flush")
external int _dc_iostream_flush(ffi.Pointer<dc_iostream_t> iostream);

dc_status_t dc_iostream_flush(ffi.Pointer<dc_iostream_t> iostream) => dc_status_t.fromValue(_dc_iostream_flush(iostream));

/// Discards all data from the internal buffers.
///
/// @param[in]  iostream   A valid I/O stream.
/// @param[in]  direction  The direction of the buffer(s).
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.UnsignedInt)>(symbol: "dc_iostream_purge")
external int _dc_iostream_purge(ffi.Pointer<dc_iostream_t> iostream, int direction);

dc_status_t dc_iostream_purge(ffi.Pointer<dc_iostream_t> iostream, dc_direction_t direction) =>
    dc_status_t.fromValue(_dc_iostream_purge(iostream, direction.value));

/// Suspend execution of the current thread for the specified amount of
/// time.
///
/// @param[in]  iostream      A valid I/O stream.
/// @param[in]  milliseconds  The number of milliseconds to sleep.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>, ffi.UnsignedInt)>(symbol: "dc_iostream_sleep")
external int _dc_iostream_sleep(ffi.Pointer<dc_iostream_t> iostream, int milliseconds);

dc_status_t dc_iostream_sleep(ffi.Pointer<dc_iostream_t> iostream, int milliseconds) => dc_status_t.fromValue(_dc_iostream_sleep(iostream, milliseconds));

/// Close the I/O stream and free all resources.
///
/// @param[in]  iostream  A valid I/O stream.
/// @returns #DC_STATUS_SUCCESS on success, or another #dc_status_t code
/// on failure.
@ffi.Native<ffi.Int Function(ffi.Pointer<dc_iostream_t>)>(symbol: "dc_iostream_close")
external int _dc_iostream_close(ffi.Pointer<dc_iostream_t> iostream);

dc_status_t dc_iostream_close(ffi.Pointer<dc_iostream_t> iostream) => dc_status_t.fromValue(_dc_iostream_close(iostream));

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<dc_device_t>>, ffi.Pointer<dc_context_t>, ffi.Pointer<dc_descriptor_t>, ffi.Pointer<dc_iostream_t>)>(
  symbol: "dc_device_open",
)
external int _dc_device_open(
  ffi.Pointer<ffi.Pointer<dc_device_t>> out,
  ffi.Pointer<dc_context_t> context,
  ffi.Pointer<dc_descriptor_t> descriptor,
  ffi.Pointer<dc_iostream_t> iostream,
);

dc_status_t dc_device_open(
  ffi.Pointer<ffi.Pointer<dc_device_t>> out,
  ffi.Pointer<dc_context_t> context,
  ffi.Pointer<dc_descriptor_t> descriptor,
  ffi.Pointer<dc_iostream_t> iostream,
) => dc_status_t.fromValue(_dc_device_open(out, context, descriptor, iostream));

@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<dc_device_t>)>(symbol: "dc_device_get_type")
external int _dc_device_get_type(ffi.Pointer<dc_device_t> device);

dc_family_t dc_device_get_type(ffi.Pointer<dc_device_t> device) => dc_family_t.fromValue(_dc_device_get_type(device));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_device_t>, dc_cancel_callback_t, ffi.Pointer<ffi.Void>)>(symbol: "dc_device_set_cancel")
external int _dc_device_set_cancel(ffi.Pointer<dc_device_t> device, dc_cancel_callback_t callback, ffi.Pointer<ffi.Void> userdata);

dc_status_t dc_device_set_cancel(ffi.Pointer<dc_device_t> device, dc_cancel_callback_t callback, ffi.Pointer<ffi.Void> userdata) =>
    dc_status_t.fromValue(_dc_device_set_cancel(device, callback, userdata));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_device_t>, ffi.UnsignedInt, dc_event_callback_t, ffi.Pointer<ffi.Void>)>(symbol: "dc_device_set_events")
external int _dc_device_set_events(ffi.Pointer<dc_device_t> device, int events, dc_event_callback_t callback, ffi.Pointer<ffi.Void> userdata);

dc_status_t dc_device_set_events(ffi.Pointer<dc_device_t> device, int events, dc_event_callback_t callback, ffi.Pointer<ffi.Void> userdata) =>
    dc_status_t.fromValue(_dc_device_set_events(device, events, callback, userdata));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_device_t>, ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>(symbol: "dc_device_set_fingerprint")
external int _dc_device_set_fingerprint(ffi.Pointer<dc_device_t> device, ffi.Pointer<ffi.UnsignedChar> data, int size);

dc_status_t dc_device_set_fingerprint(ffi.Pointer<dc_device_t> device, ffi.Pointer<ffi.UnsignedChar> data, int size) =>
    dc_status_t.fromValue(_dc_device_set_fingerprint(device, data, size));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_device_t>, ffi.UnsignedInt, ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>(symbol: "dc_device_read")
external int _dc_device_read(ffi.Pointer<dc_device_t> device, int address, ffi.Pointer<ffi.UnsignedChar> data, int size);

dc_status_t dc_device_read(ffi.Pointer<dc_device_t> device, int address, ffi.Pointer<ffi.UnsignedChar> data, int size) =>
    dc_status_t.fromValue(_dc_device_read(device, address, data, size));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_device_t>, ffi.UnsignedInt, ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>(symbol: "dc_device_write")
external int _dc_device_write(ffi.Pointer<dc_device_t> device, int address, ffi.Pointer<ffi.UnsignedChar> data, int size);

dc_status_t dc_device_write(ffi.Pointer<dc_device_t> device, int address, ffi.Pointer<ffi.UnsignedChar> data, int size) =>
    dc_status_t.fromValue(_dc_device_write(device, address, data, size));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_device_t>, ffi.Pointer<dc_buffer_t>)>(symbol: "dc_device_dump")
external int _dc_device_dump(ffi.Pointer<dc_device_t> device, ffi.Pointer<dc_buffer_t> buffer);

dc_status_t dc_device_dump(ffi.Pointer<dc_device_t> device, ffi.Pointer<dc_buffer_t> buffer) => dc_status_t.fromValue(_dc_device_dump(device, buffer));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_device_t>, dc_dive_callback_t, ffi.Pointer<ffi.Void>)>(symbol: "dc_device_foreach")
external int _dc_device_foreach(ffi.Pointer<dc_device_t> device, dc_dive_callback_t callback, ffi.Pointer<ffi.Void> userdata);

dc_status_t dc_device_foreach(ffi.Pointer<dc_device_t> device, dc_dive_callback_t callback, ffi.Pointer<ffi.Void> userdata) =>
    dc_status_t.fromValue(_dc_device_foreach(device, callback, userdata));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_device_t>, ffi.Pointer<dc_datetime_t>)>(symbol: "dc_device_timesync")
external int _dc_device_timesync(ffi.Pointer<dc_device_t> device, ffi.Pointer<dc_datetime_t> datetime);

dc_status_t dc_device_timesync(ffi.Pointer<dc_device_t> device, ffi.Pointer<dc_datetime_t> datetime) =>
    dc_status_t.fromValue(_dc_device_timesync(device, datetime));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_device_t>)>(symbol: "dc_device_close")
external int _dc_device_close(ffi.Pointer<dc_device_t> device);

dc_status_t dc_device_close(ffi.Pointer<dc_device_t> device) => dc_status_t.fromValue(_dc_device_close(device));

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Pointer<dc_parser_t>>, ffi.Pointer<dc_device_t>, ffi.Pointer<ffi.UnsignedChar>, ffi.Size)>(symbol: "dc_parser_new")
external int _dc_parser_new(ffi.Pointer<ffi.Pointer<dc_parser_t>> parser, ffi.Pointer<dc_device_t> device, ffi.Pointer<ffi.UnsignedChar> data, int size);

dc_status_t dc_parser_new(ffi.Pointer<ffi.Pointer<dc_parser_t>> parser, ffi.Pointer<dc_device_t> device, ffi.Pointer<ffi.UnsignedChar> data, int size) =>
    dc_status_t.fromValue(_dc_parser_new(parser, device, data, size));

@ffi.Native<
  ffi.Int Function(ffi.Pointer<ffi.Pointer<dc_parser_t>>, ffi.Pointer<dc_context_t>, ffi.Pointer<dc_descriptor_t>, ffi.Pointer<ffi.UnsignedChar>, ffi.Size)
>(symbol: "dc_parser_new2")
external int _dc_parser_new2(
  ffi.Pointer<ffi.Pointer<dc_parser_t>> parser,
  ffi.Pointer<dc_context_t> context,
  ffi.Pointer<dc_descriptor_t> descriptor,
  ffi.Pointer<ffi.UnsignedChar> data,
  int size,
);

dc_status_t dc_parser_new2(
  ffi.Pointer<ffi.Pointer<dc_parser_t>> parser,
  ffi.Pointer<dc_context_t> context,
  ffi.Pointer<dc_descriptor_t> descriptor,
  ffi.Pointer<ffi.UnsignedChar> data,
  int size,
) => dc_status_t.fromValue(_dc_parser_new2(parser, context, descriptor, data, size));

@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<dc_parser_t>)>(symbol: "dc_parser_get_type")
external int _dc_parser_get_type(ffi.Pointer<dc_parser_t> parser);

dc_family_t dc_parser_get_type(ffi.Pointer<dc_parser_t> parser) => dc_family_t.fromValue(_dc_parser_get_type(parser));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_parser_t>, ffi.UnsignedInt, dc_ticks_t)>(symbol: "dc_parser_set_clock")
external int _dc_parser_set_clock(ffi.Pointer<dc_parser_t> parser, int devtime, int systime);

dc_status_t dc_parser_set_clock(ffi.Pointer<dc_parser_t> parser, int devtime, Dartdc_ticks_t systime) =>
    dc_status_t.fromValue(_dc_parser_set_clock(parser, devtime, systime));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_parser_t>, ffi.Double)>(symbol: "dc_parser_set_atmospheric")
external int _dc_parser_set_atmospheric(ffi.Pointer<dc_parser_t> parser, double atmospheric);

dc_status_t dc_parser_set_atmospheric(ffi.Pointer<dc_parser_t> parser, double atmospheric) =>
    dc_status_t.fromValue(_dc_parser_set_atmospheric(parser, atmospheric));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_parser_t>, ffi.Double)>(symbol: "dc_parser_set_density")
external int _dc_parser_set_density(ffi.Pointer<dc_parser_t> parser, double density);

dc_status_t dc_parser_set_density(ffi.Pointer<dc_parser_t> parser, double density) => dc_status_t.fromValue(_dc_parser_set_density(parser, density));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_parser_t>, ffi.Pointer<dc_datetime_t>)>(symbol: "dc_parser_get_datetime")
external int _dc_parser_get_datetime(ffi.Pointer<dc_parser_t> parser, ffi.Pointer<dc_datetime_t> datetime);

dc_status_t dc_parser_get_datetime(ffi.Pointer<dc_parser_t> parser, ffi.Pointer<dc_datetime_t> datetime) =>
    dc_status_t.fromValue(_dc_parser_get_datetime(parser, datetime));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_parser_t>, ffi.UnsignedInt, ffi.UnsignedInt, ffi.Pointer<ffi.Void>)>(symbol: "dc_parser_get_field")
external int _dc_parser_get_field(ffi.Pointer<dc_parser_t> parser, int type, int flags, ffi.Pointer<ffi.Void> value);

dc_status_t dc_parser_get_field(ffi.Pointer<dc_parser_t> parser, dc_field_type_t type, int flags, ffi.Pointer<ffi.Void> value) =>
    dc_status_t.fromValue(_dc_parser_get_field(parser, type.value, flags, value));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_parser_t>, dc_sample_callback_t, ffi.Pointer<ffi.Void>)>(symbol: "dc_parser_samples_foreach")
external int _dc_parser_samples_foreach(ffi.Pointer<dc_parser_t> parser, dc_sample_callback_t callback, ffi.Pointer<ffi.Void> userdata);

dc_status_t dc_parser_samples_foreach(ffi.Pointer<dc_parser_t> parser, dc_sample_callback_t callback, ffi.Pointer<ffi.Void> userdata) =>
    dc_status_t.fromValue(_dc_parser_samples_foreach(parser, callback, userdata));

@ffi.Native<ffi.Int Function(ffi.Pointer<dc_parser_t>)>(symbol: "dc_parser_destroy")
external int _dc_parser_destroy(ffi.Pointer<dc_parser_t> parser);

dc_status_t dc_parser_destroy(ffi.Pointer<dc_parser_t> parser) => dc_status_t.fromValue(_dc_parser_destroy(parser));

enum dc_status_t {
  DC_STATUS_SUCCESS(0),
  DC_STATUS_DONE(1),
  DC_STATUS_UNSUPPORTED(-1),
  DC_STATUS_INVALIDARGS(-2),
  DC_STATUS_NOMEMORY(-3),
  DC_STATUS_NODEVICE(-4),
  DC_STATUS_NOACCESS(-5),
  DC_STATUS_IO(-6),
  DC_STATUS_TIMEOUT(-7),
  DC_STATUS_PROTOCOL(-8),
  DC_STATUS_DATAFORMAT(-9),
  DC_STATUS_CANCELLED(-10);

  final int value;
  const dc_status_t(this.value);

  static dc_status_t fromValue(int value) => switch (value) {
    0 => DC_STATUS_SUCCESS,
    1 => DC_STATUS_DONE,
    -1 => DC_STATUS_UNSUPPORTED,
    -2 => DC_STATUS_INVALIDARGS,
    -3 => DC_STATUS_NOMEMORY,
    -4 => DC_STATUS_NODEVICE,
    -5 => DC_STATUS_NOACCESS,
    -6 => DC_STATUS_IO,
    -7 => DC_STATUS_TIMEOUT,
    -8 => DC_STATUS_PROTOCOL,
    -9 => DC_STATUS_DATAFORMAT,
    -10 => DC_STATUS_CANCELLED,
    _ => throw ArgumentError("Unknown value for dc_status_t: $value"),
  };
}

final class dc_context_t extends ffi.Opaque {}

final class dc_iostream_t extends ffi.Opaque {}

enum dc_loglevel_t {
  DC_LOGLEVEL_NONE(0),
  DC_LOGLEVEL_ERROR(1),
  DC_LOGLEVEL_WARNING(2),
  DC_LOGLEVEL_INFO(3),
  DC_LOGLEVEL_DEBUG(4),
  DC_LOGLEVEL_ALL(5);

  final int value;
  const dc_loglevel_t(this.value);

  static dc_loglevel_t fromValue(int value) => switch (value) {
    0 => DC_LOGLEVEL_NONE,
    1 => DC_LOGLEVEL_ERROR,
    2 => DC_LOGLEVEL_WARNING,
    3 => DC_LOGLEVEL_INFO,
    4 => DC_LOGLEVEL_DEBUG,
    5 => DC_LOGLEVEL_ALL,
    _ => throw ArgumentError("Unknown value for dc_loglevel_t: $value"),
  };
}

typedef dc_logfunc_t = ffi.Pointer<ffi.NativeFunction<dc_logfunc_tFunction>>;
typedef dc_logfunc_tFunction =
    ffi.Void Function(
      ffi.Pointer<dc_context_t> context,
      ffi.UnsignedInt loglevel,
      ffi.Pointer<ffi.Char> file,
      ffi.UnsignedInt line,
      ffi.Pointer<ffi.Char> function,
      ffi.Pointer<ffi.Char> message,
      ffi.Pointer<ffi.Void> userdata,
    );
typedef Dartdc_logfunc_tFunction =
    void Function(
      ffi.Pointer<dc_context_t> context,
      dc_loglevel_t loglevel,
      ffi.Pointer<ffi.Char> file,
      int line,
      ffi.Pointer<ffi.Char> function,
      ffi.Pointer<ffi.Char> message,
      ffi.Pointer<ffi.Void> userdata,
    );

final class dc_iterator_t extends ffi.Opaque {}

final class dc_descriptor_t extends ffi.Opaque {}

enum dc_family_t {
  DC_FAMILY_NULL(0),

  /// Suunto
  DC_FAMILY_SUUNTO_SOLUTION(65536),
  DC_FAMILY_SUUNTO_EON(65537),
  DC_FAMILY_SUUNTO_VYPER(65538),
  DC_FAMILY_SUUNTO_VYPER2(65539),
  DC_FAMILY_SUUNTO_D9(65540),
  DC_FAMILY_SUUNTO_EONSTEEL(65541),

  /// Reefnet
  DC_FAMILY_REEFNET_SENSUS(131072),
  DC_FAMILY_REEFNET_SENSUSPRO(131073),
  DC_FAMILY_REEFNET_SENSUSULTRA(131074),

  /// Uwatec
  DC_FAMILY_UWATEC_ALADIN(196608),
  DC_FAMILY_UWATEC_MEMOMOUSE(196609),
  DC_FAMILY_UWATEC_SMART(196610),

  /// Deprecated: integrated into the Uwatec Smart family.
  DC_FAMILY_UWATEC_MERIDIAN(196611),

  /// Deprecated: integrated into the Uwatec Smart family.
  DC_FAMILY_UWATEC_G2(196612),

  /// Oceanic
  DC_FAMILY_OCEANIC_VTPRO(262144),
  DC_FAMILY_OCEANIC_VEO250(262145),
  DC_FAMILY_OCEANIC_ATOM2(262146),
  DC_FAMILY_PELAGIC_I330R(262147),

  /// Mares
  DC_FAMILY_MARES_NEMO(327680),
  DC_FAMILY_MARES_PUCK(327681),
  DC_FAMILY_MARES_DARWIN(327682),
  DC_FAMILY_MARES_ICONHD(327683),

  /// Heinrichs Weikamp
  DC_FAMILY_HW_OSTC(393216),
  DC_FAMILY_HW_FROG(393217),
  DC_FAMILY_HW_OSTC3(393218),

  /// Cressi
  DC_FAMILY_CRESSI_EDY(458752),
  DC_FAMILY_CRESSI_LEONARDO(458753),
  DC_FAMILY_CRESSI_GOA(458754),

  /// Zeagle
  DC_FAMILY_ZEAGLE_N2ITION3(524288),

  /// Atomic Aquatics
  DC_FAMILY_ATOMICS_COBALT(589824),

  /// Shearwater
  DC_FAMILY_SHEARWATER_PREDATOR(655360),
  DC_FAMILY_SHEARWATER_PETREL(655361),

  /// Dive Rite
  DC_FAMILY_DIVERITE_NITEKQ(720896),

  /// Citizen
  DC_FAMILY_CITIZEN_AQUALAND(786432),

  /// DiveSystem
  DC_FAMILY_DIVESYSTEM_IDIVE(851968),

  /// Cochran
  DC_FAMILY_COCHRAN_COMMANDER(917504),

  /// Tecdiving
  DC_FAMILY_TECDIVING_DIVECOMPUTEREU(983040),

  /// McLean
  DC_FAMILY_MCLEAN_EXTREME(1048576),

  /// Liquivision
  DC_FAMILY_LIQUIVISION_LYNX(1114112),

  /// Sporasub
  DC_FAMILY_SPORASUB_SP2(1179648),

  /// Deep Six
  DC_FAMILY_DEEPSIX_EXCURSION(1245184),

  /// Seac Screen
  DC_FAMILY_SEAC_SCREEN(1310720),

  /// Deepblu Cosmiq
  DC_FAMILY_DEEPBLU_COSMIQ(1376256),

  /// Oceans S1
  DC_FAMILY_OCEANS_S1(1441792),

  /// Divesoft Freedom
  DC_FAMILY_DIVESOFT_FREEDOM(1507328),

  /// Halcyon Symbios
  DC_FAMILY_HALCYON_SYMBIOS(1572864);

  final int value;
  const dc_family_t(this.value);

  static dc_family_t fromValue(int value) => switch (value) {
    0 => DC_FAMILY_NULL,
    65536 => DC_FAMILY_SUUNTO_SOLUTION,
    65537 => DC_FAMILY_SUUNTO_EON,
    65538 => DC_FAMILY_SUUNTO_VYPER,
    65539 => DC_FAMILY_SUUNTO_VYPER2,
    65540 => DC_FAMILY_SUUNTO_D9,
    65541 => DC_FAMILY_SUUNTO_EONSTEEL,
    131072 => DC_FAMILY_REEFNET_SENSUS,
    131073 => DC_FAMILY_REEFNET_SENSUSPRO,
    131074 => DC_FAMILY_REEFNET_SENSUSULTRA,
    196608 => DC_FAMILY_UWATEC_ALADIN,
    196609 => DC_FAMILY_UWATEC_MEMOMOUSE,
    196610 => DC_FAMILY_UWATEC_SMART,
    196611 => DC_FAMILY_UWATEC_MERIDIAN,
    196612 => DC_FAMILY_UWATEC_G2,
    262144 => DC_FAMILY_OCEANIC_VTPRO,
    262145 => DC_FAMILY_OCEANIC_VEO250,
    262146 => DC_FAMILY_OCEANIC_ATOM2,
    262147 => DC_FAMILY_PELAGIC_I330R,
    327680 => DC_FAMILY_MARES_NEMO,
    327681 => DC_FAMILY_MARES_PUCK,
    327682 => DC_FAMILY_MARES_DARWIN,
    327683 => DC_FAMILY_MARES_ICONHD,
    393216 => DC_FAMILY_HW_OSTC,
    393217 => DC_FAMILY_HW_FROG,
    393218 => DC_FAMILY_HW_OSTC3,
    458752 => DC_FAMILY_CRESSI_EDY,
    458753 => DC_FAMILY_CRESSI_LEONARDO,
    458754 => DC_FAMILY_CRESSI_GOA,
    524288 => DC_FAMILY_ZEAGLE_N2ITION3,
    589824 => DC_FAMILY_ATOMICS_COBALT,
    655360 => DC_FAMILY_SHEARWATER_PREDATOR,
    655361 => DC_FAMILY_SHEARWATER_PETREL,
    720896 => DC_FAMILY_DIVERITE_NITEKQ,
    786432 => DC_FAMILY_CITIZEN_AQUALAND,
    851968 => DC_FAMILY_DIVESYSTEM_IDIVE,
    917504 => DC_FAMILY_COCHRAN_COMMANDER,
    983040 => DC_FAMILY_TECDIVING_DIVECOMPUTEREU,
    1048576 => DC_FAMILY_MCLEAN_EXTREME,
    1114112 => DC_FAMILY_LIQUIVISION_LYNX,
    1179648 => DC_FAMILY_SPORASUB_SP2,
    1245184 => DC_FAMILY_DEEPSIX_EXCURSION,
    1310720 => DC_FAMILY_SEAC_SCREEN,
    1376256 => DC_FAMILY_DEEPBLU_COSMIQ,
    1441792 => DC_FAMILY_OCEANS_S1,
    1507328 => DC_FAMILY_DIVESOFT_FREEDOM,
    1572864 => DC_FAMILY_HALCYON_SYMBIOS,
    _ => throw ArgumentError("Unknown value for dc_family_t: $value"),
  };
}

enum dc_transport_t {
  DC_TRANSPORT_NONE(0),
  DC_TRANSPORT_SERIAL(1),
  DC_TRANSPORT_USB(2),
  DC_TRANSPORT_USBHID(4),
  DC_TRANSPORT_IRDA(8),
  DC_TRANSPORT_BLUETOOTH(16),
  DC_TRANSPORT_BLE(32);

  final int value;
  const dc_transport_t(this.value);

  static dc_transport_t fromValue(int value) => switch (value) {
    0 => DC_TRANSPORT_NONE,
    1 => DC_TRANSPORT_SERIAL,
    2 => DC_TRANSPORT_USB,
    4 => DC_TRANSPORT_USBHID,
    8 => DC_TRANSPORT_IRDA,
    16 => DC_TRANSPORT_BLUETOOTH,
    32 => DC_TRANSPORT_BLE,
    _ => throw ArgumentError("Unknown value for dc_transport_t: $value"),
  };
}

/// The parity checking scheme.
enum dc_parity_t {
  /// < No parity
  DC_PARITY_NONE(0),

  /// < Odd parity
  DC_PARITY_ODD(1),

  /// < Even parity
  DC_PARITY_EVEN(2),

  /// < Mark parity (always 1)
  DC_PARITY_MARK(3),

  /// < Space parity (alwasy 0)
  DC_PARITY_SPACE(4);

  final int value;
  const dc_parity_t(this.value);

  static dc_parity_t fromValue(int value) => switch (value) {
    0 => DC_PARITY_NONE,
    1 => DC_PARITY_ODD,
    2 => DC_PARITY_EVEN,
    3 => DC_PARITY_MARK,
    4 => DC_PARITY_SPACE,
    _ => throw ArgumentError("Unknown value for dc_parity_t: $value"),
  };
}

/// The number of stop bits.
enum dc_stopbits_t {
  /// < 1 stop bit
  DC_STOPBITS_ONE(0),

  /// < 1.5 stop bits
  DC_STOPBITS_ONEPOINTFIVE(1),

  /// < 2 stop bits
  DC_STOPBITS_TWO(2);

  final int value;
  const dc_stopbits_t(this.value);

  static dc_stopbits_t fromValue(int value) => switch (value) {
    0 => DC_STOPBITS_ONE,
    1 => DC_STOPBITS_ONEPOINTFIVE,
    2 => DC_STOPBITS_TWO,
    _ => throw ArgumentError("Unknown value for dc_stopbits_t: $value"),
  };
}

/// The flow control.
enum dc_flowcontrol_t {
  /// < No flow control
  DC_FLOWCONTROL_NONE(0),

  /// < Hardware (RTS/CTS) flow control
  DC_FLOWCONTROL_HARDWARE(1),

  /// < Software (XON/XOFF) flow control
  DC_FLOWCONTROL_SOFTWARE(2);

  final int value;
  const dc_flowcontrol_t(this.value);

  static dc_flowcontrol_t fromValue(int value) => switch (value) {
    0 => DC_FLOWCONTROL_NONE,
    1 => DC_FLOWCONTROL_HARDWARE,
    2 => DC_FLOWCONTROL_SOFTWARE,
    _ => throw ArgumentError("Unknown value for dc_flowcontrol_t: $value"),
  };
}

/// The direction of the data transmission.
enum dc_direction_t {
  /// < Input direction
  DC_DIRECTION_INPUT(1),

  /// < Output direction
  DC_DIRECTION_OUTPUT(2),

  /// < All directions
  DC_DIRECTION_ALL(3);

  final int value;
  const dc_direction_t(this.value);

  static dc_direction_t fromValue(int value) => switch (value) {
    1 => DC_DIRECTION_INPUT,
    2 => DC_DIRECTION_OUTPUT,
    3 => DC_DIRECTION_ALL,
    _ => throw ArgumentError("Unknown value for dc_direction_t: $value"),
  };
}

/// The line signals.
enum dc_line_t {
  /// < Data carrier detect
  DC_LINE_DCD(1),

  /// < Clear to send
  DC_LINE_CTS(2),

  /// < Data set ready
  DC_LINE_DSR(4),

  /// < Ring indicator
  DC_LINE_RNG(8);

  final int value;
  const dc_line_t(this.value);

  static dc_line_t fromValue(int value) => switch (value) {
    1 => DC_LINE_DCD,
    2 => DC_LINE_CTS,
    4 => DC_LINE_DSR,
    8 => DC_LINE_RNG,
    _ => throw ArgumentError("Unknown value for dc_line_t: $value"),
  };
}

enum dc_event_type_t {
  DC_EVENT_WAITING(1),
  DC_EVENT_PROGRESS(2),
  DC_EVENT_DEVINFO(4),
  DC_EVENT_CLOCK(8),
  DC_EVENT_VENDOR(16);

  final int value;
  const dc_event_type_t(this.value);

  static dc_event_type_t fromValue(int value) => switch (value) {
    1 => DC_EVENT_WAITING,
    2 => DC_EVENT_PROGRESS,
    4 => DC_EVENT_DEVINFO,
    8 => DC_EVENT_CLOCK,
    16 => DC_EVENT_VENDOR,
    _ => throw ArgumentError("Unknown value for dc_event_type_t: $value"),
  };
}

final class dc_device_t extends ffi.Opaque {}

final class dc_event_progress_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int current;

  @ffi.UnsignedInt()
  external int maximum;
}

final class dc_event_devinfo_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int model;

  @ffi.UnsignedInt()
  external int firmware;

  @ffi.UnsignedInt()
  external int serial;
}

final class dc_event_clock_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int devtime;

  @dc_ticks_t()
  external int systime;
}

typedef dc_ticks_t = ffi.LongLong;
typedef Dartdc_ticks_t = int;

final class dc_event_vendor_t extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> data;

  @ffi.UnsignedInt()
  external int size;
}

typedef dc_cancel_callback_t = ffi.Pointer<ffi.NativeFunction<dc_cancel_callback_tFunction>>;
typedef dc_cancel_callback_tFunction = ffi.Int Function(ffi.Pointer<ffi.Void> userdata);
typedef Dartdc_cancel_callback_tFunction = int Function(ffi.Pointer<ffi.Void> userdata);
typedef dc_event_callback_t = ffi.Pointer<ffi.NativeFunction<dc_event_callback_tFunction>>;
typedef dc_event_callback_tFunction =
    ffi.Void Function(ffi.Pointer<dc_device_t> device, ffi.UnsignedInt event, ffi.Pointer<ffi.Void> data, ffi.Pointer<ffi.Void> userdata);
typedef Dartdc_event_callback_tFunction =
    void Function(ffi.Pointer<dc_device_t> device, dc_event_type_t event, ffi.Pointer<ffi.Void> data, ffi.Pointer<ffi.Void> userdata);

final class dc_buffer_t extends ffi.Opaque {}

typedef dc_dive_callback_t = ffi.Pointer<ffi.NativeFunction<dc_dive_callback_tFunction>>;
typedef dc_dive_callback_tFunction =
    ffi.Int Function(
      ffi.Pointer<ffi.UnsignedChar> data,
      ffi.UnsignedInt size,
      ffi.Pointer<ffi.UnsignedChar> fingerprint,
      ffi.UnsignedInt fsize,
      ffi.Pointer<ffi.Void> userdata,
    );
typedef Dartdc_dive_callback_tFunction =
    int Function(ffi.Pointer<ffi.UnsignedChar> data, int size, ffi.Pointer<ffi.UnsignedChar> fingerprint, int fsize, ffi.Pointer<ffi.Void> userdata);

final class dc_datetime_t extends ffi.Struct {
  @ffi.Int()
  external int year;

  @ffi.Int()
  external int month;

  @ffi.Int()
  external int day;

  @ffi.Int()
  external int hour;

  @ffi.Int()
  external int minute;

  @ffi.Int()
  external int second;

  @ffi.Int()
  external int timezone;
}

enum dc_sample_type_t {
  DC_SAMPLE_TIME(0),
  DC_SAMPLE_DEPTH(1),
  DC_SAMPLE_PRESSURE(2),
  DC_SAMPLE_TEMPERATURE(3),
  DC_SAMPLE_EVENT(4),
  DC_SAMPLE_RBT(5),
  DC_SAMPLE_HEARTBEAT(6),
  DC_SAMPLE_BEARING(7),
  DC_SAMPLE_VENDOR(8),
  DC_SAMPLE_SETPOINT(9),
  DC_SAMPLE_PPO2(10),
  DC_SAMPLE_CNS(11),
  DC_SAMPLE_DECO(12),
  DC_SAMPLE_GASMIX(13);

  final int value;
  const dc_sample_type_t(this.value);

  static dc_sample_type_t fromValue(int value) => switch (value) {
    0 => DC_SAMPLE_TIME,
    1 => DC_SAMPLE_DEPTH,
    2 => DC_SAMPLE_PRESSURE,
    3 => DC_SAMPLE_TEMPERATURE,
    4 => DC_SAMPLE_EVENT,
    5 => DC_SAMPLE_RBT,
    6 => DC_SAMPLE_HEARTBEAT,
    7 => DC_SAMPLE_BEARING,
    8 => DC_SAMPLE_VENDOR,
    9 => DC_SAMPLE_SETPOINT,
    10 => DC_SAMPLE_PPO2,
    11 => DC_SAMPLE_CNS,
    12 => DC_SAMPLE_DECO,
    13 => DC_SAMPLE_GASMIX,
    _ => throw ArgumentError("Unknown value for dc_sample_type_t: $value"),
  };
}

enum dc_field_type_t {
  DC_FIELD_DIVETIME(0),
  DC_FIELD_MAXDEPTH(1),
  DC_FIELD_AVGDEPTH(2),
  DC_FIELD_GASMIX_COUNT(3),
  DC_FIELD_GASMIX(4),
  DC_FIELD_SALINITY(5),
  DC_FIELD_ATMOSPHERIC(6),
  DC_FIELD_TEMPERATURE_SURFACE(7),
  DC_FIELD_TEMPERATURE_MINIMUM(8),
  DC_FIELD_TEMPERATURE_MAXIMUM(9),
  DC_FIELD_TANK_COUNT(10),
  DC_FIELD_TANK(11),
  DC_FIELD_DIVEMODE(12),
  DC_FIELD_DECOMODEL(13),
  DC_FIELD_LOCATION(14);

  final int value;
  const dc_field_type_t(this.value);

  static dc_field_type_t fromValue(int value) => switch (value) {
    0 => DC_FIELD_DIVETIME,
    1 => DC_FIELD_MAXDEPTH,
    2 => DC_FIELD_AVGDEPTH,
    3 => DC_FIELD_GASMIX_COUNT,
    4 => DC_FIELD_GASMIX,
    5 => DC_FIELD_SALINITY,
    6 => DC_FIELD_ATMOSPHERIC,
    7 => DC_FIELD_TEMPERATURE_SURFACE,
    8 => DC_FIELD_TEMPERATURE_MINIMUM,
    9 => DC_FIELD_TEMPERATURE_MAXIMUM,
    10 => DC_FIELD_TANK_COUNT,
    11 => DC_FIELD_TANK,
    12 => DC_FIELD_DIVEMODE,
    13 => DC_FIELD_DECOMODEL,
    14 => DC_FIELD_LOCATION,
    _ => throw ArgumentError("Unknown value for dc_field_type_t: $value"),
  };
}

enum parser_sample_event_t {
  SAMPLE_EVENT_NONE(0),
  SAMPLE_EVENT_DECOSTOP(1),
  SAMPLE_EVENT_RBT(2),
  SAMPLE_EVENT_ASCENT(3),
  SAMPLE_EVENT_CEILING(4),
  SAMPLE_EVENT_WORKLOAD(5),
  SAMPLE_EVENT_TRANSMITTER(6),
  SAMPLE_EVENT_VIOLATION(7),
  SAMPLE_EVENT_BOOKMARK(8),
  SAMPLE_EVENT_SURFACE(9),
  SAMPLE_EVENT_SAFETYSTOP(10),

  /// Deprecated: replaced by DC_SAMPLE_GASMIX.
  SAMPLE_EVENT_GASCHANGE(11),
  SAMPLE_EVENT_SAFETYSTOP_VOLUNTARY(12),
  SAMPLE_EVENT_SAFETYSTOP_MANDATORY(13),
  SAMPLE_EVENT_DEEPSTOP(14),
  SAMPLE_EVENT_CEILING_SAFETYSTOP(15),
  SAMPLE_EVENT_FLOOR(16),
  SAMPLE_EVENT_DIVETIME(17),
  SAMPLE_EVENT_MAXDEPTH(18),
  SAMPLE_EVENT_OLF(19),
  SAMPLE_EVENT_PO2(20),
  SAMPLE_EVENT_AIRTIME(21),
  SAMPLE_EVENT_RGBM(22),
  SAMPLE_EVENT_HEADING(23),
  SAMPLE_EVENT_TISSUELEVEL(24),

  /// Deprecated: replaced by DC_SAMPLE_GASMIX.
  SAMPLE_EVENT_GASCHANGE2(25);

  final int value;
  const parser_sample_event_t(this.value);

  static parser_sample_event_t fromValue(int value) => switch (value) {
    0 => SAMPLE_EVENT_NONE,
    1 => SAMPLE_EVENT_DECOSTOP,
    2 => SAMPLE_EVENT_RBT,
    3 => SAMPLE_EVENT_ASCENT,
    4 => SAMPLE_EVENT_CEILING,
    5 => SAMPLE_EVENT_WORKLOAD,
    6 => SAMPLE_EVENT_TRANSMITTER,
    7 => SAMPLE_EVENT_VIOLATION,
    8 => SAMPLE_EVENT_BOOKMARK,
    9 => SAMPLE_EVENT_SURFACE,
    10 => SAMPLE_EVENT_SAFETYSTOP,
    11 => SAMPLE_EVENT_GASCHANGE,
    12 => SAMPLE_EVENT_SAFETYSTOP_VOLUNTARY,
    13 => SAMPLE_EVENT_SAFETYSTOP_MANDATORY,
    14 => SAMPLE_EVENT_DEEPSTOP,
    15 => SAMPLE_EVENT_CEILING_SAFETYSTOP,
    16 => SAMPLE_EVENT_FLOOR,
    17 => SAMPLE_EVENT_DIVETIME,
    18 => SAMPLE_EVENT_MAXDEPTH,
    19 => SAMPLE_EVENT_OLF,
    20 => SAMPLE_EVENT_PO2,
    21 => SAMPLE_EVENT_AIRTIME,
    22 => SAMPLE_EVENT_RGBM,
    23 => SAMPLE_EVENT_HEADING,
    24 => SAMPLE_EVENT_TISSUELEVEL,
    25 => SAMPLE_EVENT_GASCHANGE2,
    _ => throw ArgumentError("Unknown value for parser_sample_event_t: $value"),
  };
}

enum parser_sample_flags_t {
  SAMPLE_FLAGS_NONE(0),
  SAMPLE_FLAGS_BEGIN(1),
  SAMPLE_FLAGS_END(2);

  final int value;
  const parser_sample_flags_t(this.value);

  static parser_sample_flags_t fromValue(int value) => switch (value) {
    0 => SAMPLE_FLAGS_NONE,
    1 => SAMPLE_FLAGS_BEGIN,
    2 => SAMPLE_FLAGS_END,
    _ => throw ArgumentError("Unknown value for parser_sample_flags_t: $value"),
  };
}

enum parser_sample_vendor_t {
  SAMPLE_VENDOR_NONE(0),
  SAMPLE_VENDOR_UWATEC_ALADIN(1),
  SAMPLE_VENDOR_UWATEC_SMART(2),
  SAMPLE_VENDOR_OCEANIC_VTPRO(3),
  SAMPLE_VENDOR_OCEANIC_VEO250(4),
  SAMPLE_VENDOR_OCEANIC_ATOM2(5);

  final int value;
  const parser_sample_vendor_t(this.value);

  static parser_sample_vendor_t fromValue(int value) => switch (value) {
    0 => SAMPLE_VENDOR_NONE,
    1 => SAMPLE_VENDOR_UWATEC_ALADIN,
    2 => SAMPLE_VENDOR_UWATEC_SMART,
    3 => SAMPLE_VENDOR_OCEANIC_VTPRO,
    4 => SAMPLE_VENDOR_OCEANIC_VEO250,
    5 => SAMPLE_VENDOR_OCEANIC_ATOM2,
    _ => throw ArgumentError("Unknown value for parser_sample_vendor_t: $value"),
  };
}

enum dc_water_t {
  DC_WATER_FRESH(0),
  DC_WATER_SALT(1);

  final int value;
  const dc_water_t(this.value);

  static dc_water_t fromValue(int value) => switch (value) {
    0 => DC_WATER_FRESH,
    1 => DC_WATER_SALT,
    _ => throw ArgumentError("Unknown value for dc_water_t: $value"),
  };
}

enum dc_divemode_t {
  DC_DIVEMODE_FREEDIVE(0),
  DC_DIVEMODE_GAUGE(1),

  /// Open circuit
  DC_DIVEMODE_OC(2),

  /// Closed circuit rebreather
  DC_DIVEMODE_CCR(3),

  /// Semi-closed circuit rebreather
  DC_DIVEMODE_SCR(4);

  final int value;
  const dc_divemode_t(this.value);

  static dc_divemode_t fromValue(int value) => switch (value) {
    0 => DC_DIVEMODE_FREEDIVE,
    1 => DC_DIVEMODE_GAUGE,
    2 => DC_DIVEMODE_OC,
    3 => DC_DIVEMODE_CCR,
    4 => DC_DIVEMODE_SCR,
    _ => throw ArgumentError("Unknown value for dc_divemode_t: $value"),
  };
}

enum dc_deco_type_t {
  DC_DECO_NDL(0),
  DC_DECO_SAFETYSTOP(1),
  DC_DECO_DECOSTOP(2),
  DC_DECO_DEEPSTOP(3);

  final int value;
  const dc_deco_type_t(this.value);

  static dc_deco_type_t fromValue(int value) => switch (value) {
    0 => DC_DECO_NDL,
    1 => DC_DECO_SAFETYSTOP,
    2 => DC_DECO_DECOSTOP,
    3 => DC_DECO_DEEPSTOP,
    _ => throw ArgumentError("Unknown value for dc_deco_type_t: $value"),
  };
}

final class dc_salinity_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int type;

  @ffi.Double()
  external double density;
}

enum dc_usage_t {
  DC_USAGE_NONE(0),
  DC_USAGE_OXYGEN(1),
  DC_USAGE_DILUENT(2),
  DC_USAGE_SIDEMOUNT(3);

  final int value;
  const dc_usage_t(this.value);

  static dc_usage_t fromValue(int value) => switch (value) {
    0 => DC_USAGE_NONE,
    1 => DC_USAGE_OXYGEN,
    2 => DC_USAGE_DILUENT,
    3 => DC_USAGE_SIDEMOUNT,
    _ => throw ArgumentError("Unknown value for dc_usage_t: $value"),
  };
}

final class dc_gasmix_t extends ffi.Struct {
  @ffi.Double()
  external double helium;

  @ffi.Double()
  external double oxygen;

  @ffi.Double()
  external double nitrogen;

  @ffi.UnsignedInt()
  external int usage;
}

enum dc_tankvolume_t {
  DC_TANKVOLUME_NONE(0),
  DC_TANKVOLUME_METRIC(1),
  DC_TANKVOLUME_IMPERIAL(2);

  final int value;
  const dc_tankvolume_t(this.value);

  static dc_tankvolume_t fromValue(int value) => switch (value) {
    0 => DC_TANKVOLUME_NONE,
    1 => DC_TANKVOLUME_METRIC,
    2 => DC_TANKVOLUME_IMPERIAL,
    _ => throw ArgumentError("Unknown value for dc_tankvolume_t: $value"),
  };
}

/// Tank volume
///
/// There are two different ways to specify the volume of a tank. In the
/// metric system, the tank volume is specified as the water capacity,
/// while in the imperial system the tank volume is specified as the air
/// capacity at the surface (1 ATM) when the tank is filled at its
/// working pressure. Libdivecomputer will always convert the tank volume
/// to the metric representation, and indicate the original tank type:
///
/// DC_TANKVOLUME_NONE: Tank volume is not available. Both the volume and
/// workpressure will be zero.
///
/// DC_TANKVOLUME_METRIC: A metric tank. The workpressure is optional and
/// may be zero.
///
/// DC_TANKVOLUME_IMPERIAL: An imperial tank. Both the volume and
/// workpressure are mandatory and always non-zero. The volume has been
/// converted from air capacity to water capacity. To calculate the
/// original air capacity again, multiply with the workpressure and
/// divide by 1 ATM (Vair = Vwater * Pwork / Patm).
final class dc_tank_t extends ffi.Struct {
  /// Gas mix index, or DC_GASMIX_UNKNOWN
  @ffi.UnsignedInt()
  external int gasmix;

  /// Tank type
  @ffi.UnsignedInt()
  external int type;

  /// Volume (liter)
  @ffi.Double()
  external double volume;

  /// Work pressure (bar)
  @ffi.Double()
  external double workpressure;

  /// Begin pressure (bar)
  @ffi.Double()
  external double beginpressure;

  /// End pressure (bar)
  @ffi.Double()
  external double endpressure;

  @ffi.UnsignedInt()
  external int usage;
}

enum dc_decomodel_type_t {
  DC_DECOMODEL_NONE(0),
  DC_DECOMODEL_BUHLMANN(1),
  DC_DECOMODEL_VPM(2),
  DC_DECOMODEL_RGBM(3),
  DC_DECOMODEL_DCIEM(4);

  final int value;
  const dc_decomodel_type_t(this.value);

  static dc_decomodel_type_t fromValue(int value) => switch (value) {
    0 => DC_DECOMODEL_NONE,
    1 => DC_DECOMODEL_BUHLMANN,
    2 => DC_DECOMODEL_VPM,
    3 => DC_DECOMODEL_RGBM,
    4 => DC_DECOMODEL_DCIEM,
    _ => throw ArgumentError("Unknown value for dc_decomodel_type_t: $value"),
  };
}

/// Decompression model
///
/// The type field contains the decompression algorithm.
///
/// The (optional) conservatism field contains the personal adjustment
/// setting of the algorithm. The exact interpretation depends on the
/// dive computer, but the default value (zero) will typically correspond
/// to the neutral setting, while a positive value is more conservative
/// and a negative value more aggressive.
///
/// The (optional) params field contains the parameters of the algorithm:
///
/// DC_DECOMODEL_BUHLMANN: The Gradient Factor (GF) parameters low and
/// high. For a pure Buhlmann algorithm (e.g. without GF enabled), both
/// values are 100. If GF are enabled, but the actual parameter values
/// are not available from the dive computer, both values are zero.
final class dc_decomodel_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int type;

  @ffi.Int()
  external int conservatism;

  external UnnamedUnion1 params;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 gf;
}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int high;

  @ffi.UnsignedInt()
  external int low;
}

/// GPS Location
///
/// The latitude and longitude are in decimal degrees, and the (optional)
/// altitude in meters.
final class dc_location_t extends ffi.Struct {
  @ffi.Double()
  external double latitude;

  @ffi.Double()
  external double longitude;

  @ffi.Double()
  external double altitude;
}

final class dc_sample_value_t extends ffi.Union {
  /// Milliseconds
  @ffi.UnsignedInt()
  external int time;

  @ffi.Double()
  external double depth;

  external UnnamedStruct2 pressure;

  @ffi.Double()
  external double temperature;

  external UnnamedStruct3 event;

  @ffi.UnsignedInt()
  external int rbt;

  @ffi.UnsignedInt()
  external int heartbeat;

  @ffi.UnsignedInt()
  external int bearing;

  external UnnamedStruct4 vendor;

  @ffi.Double()
  external double setpoint;

  external UnnamedStruct5 ppo2;

  @ffi.Double()
  external double cns;

  external UnnamedStruct6 deco;

  /// Gas mix index
  @ffi.UnsignedInt()
  external int gasmix;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int tank;

  @ffi.Double()
  external double value;
}

final class UnnamedStruct3 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int type;

  @ffi.UnsignedInt()
  external int time;

  @ffi.UnsignedInt()
  external int flags;

  @ffi.UnsignedInt()
  external int value;
}

final class UnnamedStruct4 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int type;

  @ffi.UnsignedInt()
  external int size;

  external ffi.Pointer<ffi.Void> data;
}

final class UnnamedStruct5 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int sensor;

  @ffi.Double()
  external double value;
}

final class UnnamedStruct6 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int type;

  @ffi.UnsignedInt()
  external int time;

  @ffi.Double()
  external double depth;

  @ffi.UnsignedInt()
  external int tts;
}

final class dc_parser_t extends ffi.Opaque {}

typedef dc_sample_callback_t = ffi.Pointer<ffi.NativeFunction<dc_sample_callback_tFunction>>;
typedef dc_sample_callback_tFunction = ffi.Void Function(ffi.UnsignedInt type, ffi.Pointer<dc_sample_value_t> value, ffi.Pointer<ffi.Void> userdata);
typedef Dartdc_sample_callback_tFunction = void Function(dc_sample_type_t type, ffi.Pointer<dc_sample_value_t> value, ffi.Pointer<ffi.Void> userdata);

const int SAMPLE_EVENT_UNKNOWN = 16;

const int DC_DIVEMODE_CC = 3;

const int DC_SENSOR_NONE = 4294967295;

const int DC_GASMIX_UNKNOWN = 4294967295;
